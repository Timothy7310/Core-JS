# Render

## When is a component rendered?

Существует *4 причины*, по которым компонент подвергается *ререндерингу*:
1. изменение состояния
2. ререндеринг родительского компонента
3. изменение контекста
4. изменение хука.

### Изменение состояния
Компонент всегда подвергается *ререндерингу* при изменении его состояния. Обычно, это происходит в хуке `useState` или `useReducer`.

![image](https://user-images.githubusercontent.com/55184984/235942025-ed4a03c3-7aed-4b10-ab5f-cf88ad449b8d.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part2-1-re-renders-because-of-state-ngh8uc?file=/src/App.tsx)

### Ререндеринг родительского компонента
Компонент подвергается *ререндерингу* при повторном рендеринге его родительского компонента. Другими словами, когда компонент повторно рендерится, его потомки также *ререндерятся*.

Ререндеринг «спускается» вниз по дереву компонентов: повторный рендеринг дочернего компонента не влечет *ререндеринг* его предка

![image](https://user-images.githubusercontent.com/55184984/235942754-39191159-c217-4447-ad3d-c6eed05c890b.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part-2-2-re-renders-because-of-parent-b0xvxt?file=/src/App.tsx)

### Изменение контекста
При изменении значения, передаваемого в провайдер контекста `(Context Provider)`, все компоненты, потребляющие (consume) `контекст` (эти значения), подвергаются *повторному рендерингу*,  
даже если они не используют модифицированные данные.

![image](https://user-images.githubusercontent.com/55184984/235943788-c02d6ad4-5475-4fa6-bdfe-f523e68347ee.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part-2-3-re-render-because-of-context-i75lwh?file=/src/App.tsx)

### Изменение хука
Все, что происходит внутри хука, «принадлежит» использующему его компоненту. Здесь действуют те же правила:
  + изменение состояния хука влечет безусловный *ререндеринг* «хостового» (host) компонента;
  + если хук потребляет контекст, модификация контекста повлечет безусловный ререндеринг компонента, использующего хук.

Хуки могут вызываться по цепочке. Каждый хук в цепочке принадлежит хостовому компоненту — модификация любого хука влечет безусловный *ререндеринг* соответствующего компонента.

![image](https://user-images.githubusercontent.com/55184984/235944739-61ec92a2-6bfc-48d1-8588-fb151d2f0de8.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part-2-4-re-render-because-of-hooks-5kpdrp?file=/src/App.tsx)

### Изменение пропов (распространенное заблуждение)
До тех пор, пока речь не идет о мемоизированных компонентах, изменения пропов особого значения не имеют.

Модификация пропов означает их **обновление родительским компонентом**. Это, в свою очередь, означает *ререндеринг* родительского компонента, влекущий *повторный рендеринг* всех его потомков.
Изменения пропов становятся важными только при применении различных техник мемоизации (`React.memo`, `useMemo`).

![image](https://user-images.githubusercontent.com/55184984/235945393-b0508fdc-27a3-458f-b180-0caa2b3a2709.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part-2-5-re-render-props-not-relevant-2b8o0p?file=/src/App.tsx)

### this.forceUpdate()
Классовые компоненты можно обновить с помощью `this.forceUpdate()`, а для функциональных компонентов можно получить похожее поведение используя хук `useReducer`, который всегда увеливает счетчик:
```js
const [, forceRender] = useReducer((c) => c + 1, 0);
```

## How not to render on props change?
### Предотвращение ререндеринга с помощью React.memo
Оборачивание компонента в `React.memo` останавливает нисходящую цепочку *ререндерингов*, запущенную где-то выше в дереве компонентов, **до тех пор, пока пропы остаются неизменными**.

Может использоваться в тяжелых компонентах, не зависящих от источника *ререндеринга* (состояние, данные и др.).

![image](https://user-images.githubusercontent.com/55184984/235949577-b8b8291d-ce4d-4179-86bb-6724ef42f6fc.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part-4-simple-memo-fz4xhw?file=/src/App.tsx)

### React.memo: компонент с пропами
Все пропы, которые не являются примитивными значениями, должны *мемоизироваться*, например, с помощью хука `useMemo` до передачи компоненту, мемоизируемому с помощью `React.memo`.

![image](https://user-images.githubusercontent.com/55184984/235949879-0f8ff058-cd7a-4459-8346-84676c3afd83.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part-4-1-memo-on-component-with-props-fq55hm?file=/src/App.tsx)

### React.memo: компоненты, передаваемыми в виде пропов, или потомки
Компоненты, передаваемые другим компонентам как пропы, или дочерние компоненты должны *мемоизироваться* с помощью `React.memo`.   
Мемоизация родительского компонента работать не будет: потомки и компоненты-пропы — это объекты, которые будут разными при каждом рендеринге.

![image](https://user-images.githubusercontent.com/55184984/235950700-4bc54a6b-7e8e-4147-89e4-49fd07de3c8e.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part-4-2-memo-on-components-in-props-55tebl?file=/src/App.tsx)

### Использование useMemo для «дорогих» вычислений
Хук `useMemo` предназначен для предотвращения дорогих с точки зрения производительности вычислений при повторных рендерингах.

Использование `useMemo` имеет свою цену: **потребляется больше памяти и, как следствие, первоначальный рендеринг становится медленнее**.  
Поэтому его следует применять с умом. В React самые дорогие вычисления производятся при монтировании и обновлении компонентов.

Поэтому типичным примером использования `useMemo` является *мемоизация React-элементов*.  
Такими элементами, как правило, является часть существующего дерева рендеринга или результат генерации такого дерева, например, функция `map`, возвращающая массив элементов

Стоимость «чистых» операций, таких как сортировка или фильтрация массива, обычно, являются незначительными по сравнению с обновлениями компонентов.

![image](https://user-images.githubusercontent.com/55184984/235951542-e8e9a7bc-2af0-48ee-b520-0c9db6843d2b.png)

[Пример на CodeSandbox](https://codesandbox.io/s/part-5-3-usememo-for-expensive-calculations-trx97x?file=/src/App.tsx)

`React.memo` затрагивает только изменения пропсов. Если функциональный компонент обёрнут в `React.memo` и использует `useState`, `useReducer` или `useContext`, он будет повторно рендериться при изменении состояния или контекста.

По умолчанию он поверхностно сравнивает вложенные объекты в объекте `props`. Если вы хотите контролировать сравнение, вы можете передать свою функцию сравнения в качестве второго аргумента.

```js
function MyComponent(props) {
  /* рендер с использованием пропсов */
}
function areEqual(prevProps, nextProps) {
  /*
  возвращает true, если nextProps рендерит
  тот же результат что и prevProps,
  иначе возвращает false
  */
}
export default React.memo(MyComponent, areEqual);
```

## Is it OK to use arrow functions in render methods?
В целом, да. Зачастую это самый простой способ передать параметры через колбэки.

## Блок-схема

![image](https://user-images.githubusercontent.com/55184984/235952831-2a02d0ff-a2b0-44a3-9562-ae20aa59caff.png)


## Links
+ [When Does React Render Your Component?](https://www.zhenghao.io/posts/react-rerender#the-flow-chart)
+ [Complete Guide to React Rendering Behavior](https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#rules-of-react-rendering)
+ [React: полное руководство по повторному рендерингу](https://habr.com/ru/companies/timeweb/articles/684718/)
